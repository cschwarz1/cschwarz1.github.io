<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>kernel driver bughunting: setup and exploring permissions and entry points | home</title><meta name=keywords content><meta name=description content="This blog post is about setting up a testing environment for Windows kernel driver vulnerabilities. We will look at obtaining and loading target kernel drivers, analyze permissions and injecting payloads from user-land. I'll post some links for a full testing setup as well, so you can get started on hacking your own drivers in no time."><meta name=author content="c"><link rel=canonical href=https://cschwarz1.github.io/posts/0x03/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ef433f52b2f4200b69b3e4cc7a716c6232d42296fab86ed36376595a2896714d.css integrity="sha256-70M/UrL0IAtps+TMenFsYjLUIpb6uG7TY3ZZWiiWcU0=" rel="preload stylesheet" as=style><link rel=icon href=https://cschwarz1.github.io/favicon.ico><link rel=apple-touch-icon href=https://cschwarz1.github.io/apple-touch-icon.png><meta name=twitter:card content="summary"><meta name=twitter:title content="kernel driver bughunting: setup and exploring permissions and entry points | home"><meta name=twitter:description content="This blog post is about setting up a testing environment for Windows kernel driver vulnerabilities. We will look at obtaining and loading target kernel drivers, analyze permissions and injecting payloads from user-land. I'll post some links for a full testing setup as well, so you can get started on hacking your own drivers in no time."><meta property="og:title" content="kernel driver bughunting: setup and exploring permissions and entry points | home"><meta property="og:description" content="This blog post is about setting up a testing environment for Windows kernel driver vulnerabilities. We will look at obtaining and loading target kernel drivers, analyze permissions and injecting payloads from user-land. I'll post some links for a full testing setup as well, so you can get started on hacking your own drivers in no time."><meta property="og:type" content="article"><meta property="og:url" content="https://cschwarz1.github.io/posts/0x03/"><meta property="og:image" content="https://cschwarz1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-19T23:05:45+01:00"><meta property="article:modified_time" content="2023-06-19T23:05:45+01:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cschwarz1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"kernel driver bughunting: setup and exploring permissions and entry points","item":"https://cschwarz1.github.io/posts/0x03/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kernel driver bughunting: setup and exploring permissions and entry points | home","name":"kernel driver bughunting: setup and exploring permissions and entry points","description":"This blog post is about setting up a testing environment for Windows kernel driver vulnerabilities. We will look at obtaining and loading target kernel drivers, analyze permissions and injecting payloads from user-land. I'll post some links for a full testing setup as well, so you can get started on hacking your own drivers in no time.","keywords":[],"wordCount":"1639","inLanguage":"en","datePublished":"2023-06-19T23:05:45+01:00","dateModified":"2023-06-19T23:05:45+01:00","author":{"@type":"Person","name":"c"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cschwarz1.github.io/posts/0x03/"},"publisher":{"@type":"Organization","name":"home","logo":{"@type":"ImageObject","url":"https://cschwarz1.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body class="dark type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="dark",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://cschwarz1.github.io/ accesskey=h title="home (Alt + H)">home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cschwarz1.github.io/categories/ title=categories>categories</a></li><li><a href=https://cschwarz1.github.io/tags/ title=tags>tags</a></li><li><a href=https://cschwarz1.github.io/aboutme/ title="about me">about me</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>kernel driver bughunting: setup and exploring permissions and entry points</h1><div class=post-description>This blog post is about setting up a testing environment for Windows kernel driver vulnerabilities. We will look at obtaining and loading target kernel drivers, analyze permissions and injecting payloads from user-land. I'll post some links for a full testing setup as well, so you can get started on hacking your own drivers in no time.</div><div class=post-meta><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg><span>June 19, 2023</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>1639 words</span></span><span class=meta-item><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>8 min</span></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#obtaining-kernel-drivers aria-label="obtaining kernel drivers">obtaining kernel drivers</a></li><li><a href=#choosing-a-target aria-label="choosing a target">choosing a target</a></li></ul></div></details></div><div class=post-content><p>In this blog post series, I am documenting the development process of an implant, which can be used in adversary simulation tests aka red team operations.</p><p>Our implant will load a signed driver to execute ring-0 code and hook, bypass, or simply kill the AV/EDR. When drivers are cross-signed by Microsoft, they <strong>should</strong> be inherently trusted by security solutions and since the drivers run with kernel-level privileges, we would be able to bypass behavior-based detections and kernel callback hooking.
We will also take a look at how we can interrupt or forge telemetry, how PPL can be accessed via memory operations and how we can deal with VBS.</p><p>Throughout the development of the implant, we assume admin privileges on a compromised host, either through stolen credentials, local privilege escalation, DNS Fallback account take-overs, compromised misconfigured web applications, and so on and so forth.</p><p>I&rsquo;ll publish a couple of (responsible disclosed) findings and some code and if you familiarize yourself with the concepts it should be doable to write your implant you can use in your engagements. Since most of the concepts and techniques are documented plentiful all over the internet and researched thoroughly, we will just combine the best ones and throw together some custom code we can actively use for AV/EDR evasion.</p><p>I highly suggest researching your vulnerable driver as these techniques will probably be valuable for quite some time. VBS is still early, and think about how many Windows Server 2008 and 2012 boxes are lurking around in intranets nowadays. Kernel driver-based (BYOVD) attack paths are here to stay for the foreseeable future.</p><p>So grab your <a href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver>HEVD</a> or research your vulnerable driver and let&rsquo;s go.</p><p>So first we will take a look and a very simplified approach to how kernel driver vulnerabilities can be identified and leveraged to execute arbitrary ring-0 privileged code on a fully patched win10 2202 system, how to bypass some of the current kernel protections, and some caveats and pitfalls one might encounter.
At this point, I can not share the specific kernel driver I used for the exploitation, as this is still under an embargo due to responsible disclosure. The concepts however will apply to most kernel driver vulnerability research.</p><h2 id=obtaining-kernel-drivers>obtaining kernel drivers</h2><p>First, we need some drivers to analyze. There are a gazillion Windows drivers out there, I opted to download a driver package found in the interwebs. It was almost 35 gigabytes of pure driver madness and consisted mostly of very old unsigned drivers, which are not useful for our purpose. So I hacked together a very basic Python script, to check for a valid [[windows driver signatures]] signature and if the driver loads without any other hardware attached or additional software installed. The result should be a standalone <code>.sys</code> file that can be loaded as a kernel driver in a Windows service on a standard Windows 10 system.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>os</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>subprocess</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Set the directory containing the driver files</span>
</span></span><span class=line><span class=cl><span class=n>driver_directory</span> <span class=o>=</span> <span class=s2>&#34;C:</span><span class=se>\\</span><span class=s2>drivers&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Iterate over all files in the driver directory</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>filename</span> <span class=ow>in</span> <span class=n>os</span><span class=o>.</span><span class=n>listdir</span><span class=p>(</span><span class=n>driver_directory</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>filename</span><span class=o>.</span><span class=n>endswith</span><span class=p>(</span><span class=s2>&#34;.sys&#34;</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># Use the signtool utility to verify the digital signature of the file</span>
</span></span><span class=line><span class=cl>        <span class=n>command</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;signtool&#34;</span><span class=p>,</span> <span class=s2>&#34;verify&#34;</span><span class=p>,</span> <span class=s2>&#34;/pa&#34;</span><span class=p>,</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>driver_directory</span><span class=p>,</span> <span class=n>filename</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>command</span><span class=p>,</span> <span class=n>capture_output</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>text</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1># If the signature is valid, start the driver as a service</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=s2>&#34;SIGNED&#34;</span> <span class=ow>in</span> <span class=n>result</span><span class=o>.</span><span class=n>stdout</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>service_name</span> <span class=o>=</span> <span class=n>os</span><span class=o>.</span><span class=n>path</span><span class=o>.</span><span class=n>splitext</span><span class=p>(</span><span class=n>filename</span><span class=p>)[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>command</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;sc&#34;</span><span class=p>,</span> <span class=s2>&#34;create&#34;</span><span class=p>,</span> <span class=n>service_name</span><span class=p>,</span> <span class=s2>&#34;type=kernel&#34;</span><span class=p>,</span> <span class=s2>&#34;error=normal&#34;</span><span class=p>,</span> <span class=s2>&#34;binPath=C:</span><span class=se>\\</span><span class=s2>drivers</span><span class=se>\\</span><span class=s2>&#34;</span> <span class=o>+</span> <span class=n>filename</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=n>subprocess</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>command</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Service created for&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Invalid signature for&#34;</span><span class=p>,</span> <span class=n>filename</span><span class=p>)</span>
</span></span></code></pre></div><p>After a couple of hours and countless BSODs, I finally ended up with 249 loaded drivers.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230117_104453.png width=500px height=500></figure><p>Kernel drivers are loaded via Windows service. The commands are seen below and should be self-explanatory.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230119_101145%202.png></figure><h2 id=choosing-a-target>choosing a target</h2><p>When deciding on which driver to analyze it helps to get some insights on the binary file first. We can use <code>dumpbin</code> to investigate the Import Address Table, and get an idea if any dangerous and potential vulnerable function calls into <code>ntoskrnl.exe</code> are made. Kernel drivers are usually used for interacting with hardware, that why they often implement some kind of direct memory manipulation routines. Suspicious imports include everything that copies memory like <code>RTLCopyMemory</code>, <code>memcpy</code>, <code>memmove</code>, and so on. Special Windows APIs such as <code>MmMapIoSpace</code> and friends <code>IoAllocateMdl</code>, <code>MmBuildMdlForNonPagedPool</code> and <code>ZwMapViewOfSection</code> usually indicate processing physical memory.</p><p>The list is far from complete as there are many logic bugs in kernel drivers, like copying between virtual memory pointers or calling some specific CPU functions like <code>rdmsr</code> and <code>wrmsr</code>. Again, you can find most of these and others worthwhile investigating online as there has been a lot of vulnerability research going on. There is even a framework for exploiting some of the bugs [https://back.engineering/22/03/2021/].</p><p>I scripted a batch file and let it run over my collection of loadable drivers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-powershell data-lang=powershell><span class=line><span class=cl><span class=nv>@echo</span> <span class=n>off</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>SETLOCAL</span> <span class=n>ENABLEDELAYEDEXPANSION</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>/</span><span class=nb>r </span><span class=p>.</span> <span class=p>%</span><span class=k>%</span><span class=n>a</span> <span class=k>in</span> <span class=p>(*.</span><span class=n>sys</span><span class=p>)</span> <span class=k>do</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=nb>set </span><span class=n>full_path</span><span class=p>=%</span><span class=k>%</span><span class=n>a</span>
</span></span><span class=line><span class=cl>        <span class=nb>set </span><span class=n>filename_ext</span><span class=p>=%%~</span><span class=n>nxa</span>
</span></span><span class=line><span class=cl>        <span class=nb>set </span><span class=n>filename</span><span class=p>=%%~</span><span class=n>na</span>
</span></span><span class=line><span class=cl>        <span class=nb>set </span><span class=n>extension</span><span class=p>=%%~</span><span class=n>xa</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>dumpbin</span> <span class=p>/</span><span class=n>imports</span> <span class=p>!</span><span class=n>filename_ext</span><span class=p>!</span> <span class=p>|</span> <span class=n>findstr</span> <span class=p>/</span><span class=n>i</span> <span class=p>/</span><span class=n>M</span> <span class=k>%</span><span class=mf>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>!</span><span class=n>errorlevel</span><span class=p>!==</span><span class=mf>0</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>                <span class=nb>echo </span><span class=p>!</span><span class=n>filename</span><span class=p>!</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div><p>Here you can see the output of the script and some of the potential candidates.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230209_043828%201.png width=700px height=400></figure><p>Let&rsquo;s open the first driver in Ghidra and start reversing. I applied some specific kernel API <a href=https://github.com/0x6d696368/ghidra-data/tree/master/typeinfo>function signatures</a> to make life easier, thanks 0x6d696368.</p><p>I&rsquo;ll not go into the nitty-gritty details on how IOCTL and the IRP handling works as these are not really needed for bug hunting and there is already a lot of information about this online.
The important thing is getting access to the functionalities of the kernel driver from user-mode and this is done via specific handlers calling IOCTLs.</p><p>It is maybe noteworthy that the IOCTLs themselves have some access bits set, to control who is allowed to call that specific IOCTL. you can find some details about the IOCTL struct [here]</p><p>I&rsquo;ll also briefly explain how you can examine the access rights your driver needs to handle IOCTLs. In case you want to responsible disclose your findings you&rsquo;ll need to show impact and having a medium integrity process allowed to open a handle to the driver will get this triaged (maybe). Otherwise you probably won&rsquo;t even get a reply from the vendor as most of them consider exploitation with admin rights not a vulnerability.</p><p>We can start in graph view and look for long <code>cmp</code> opcode chains to match the IOCTL to their handler implementation.</p><p>Once analyzed by Ghidra, the <code>entry</code> function will already be disassembled and you can select it in the <em>function window</em>.
I marked and renamed the most relevant function call in red, as this is where the IOCTL handlers are implemented.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230208_064806%202.png></figure><p>To get the necessary information, specifically the offsets to where the IOCTLs are getting processed we need to fire up the kernel debugger and investigate. If you are new to kernel debugging I can recommend <a href=https://voidsec.com/windows-kernel-debugging-exploitation/>voidsec&rsquo;s</a> excellent tutorial on how to setup remote sessions with WinDBG.</p><figure class=center><img loading=lazy src=/images/1_anon%201.png></figure><p>We can get our device object address:</p><figure class=center><img loading=lazy src=/images/2_anon%201.png></figure><p>if we take a look at how the driver struct is</p><figure class=center><img loading=lazy src=/images/Screenshot_20230208_113208%201.png></figure><p>at offset <code>+0x18</code> is our driver start address, we can configure Ghidra to use that offfset as base. More on that later.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230213_040538.png></figure><p>we can als use the <code>lm</code> command to get the same informaiton, but you eed to provide the exact name of the module, which in some cases can be very different from the filename or service.</p><p>The module list start adress is the same as <code>DriverStart</code></p><pre tabindex=0><code class=language-windbg data-lang=windbg>2: kd&gt; .reload
Connected to Windows 10 19041 x64 target at (Mon Feb 13 17:26:25.413 2023 (UTC + 1:00)), ptr64 TRUE
Loading Kernel Symbols
...............................................................
................................................................
.............................................
Loading User Symbols

Loading unloaded module list
................Unable to enumerate user-mode unloaded modules, Win32 error 0n30

************* Symbol Loading Error Summary **************
Module name            Error
SharedUserData         No error - symbol load deferred

You can troubleshoot most symbol related issues by turning on symbol loading diagnostics (!sym noisy) and repeating the command that caused symbols to be loaded.
You should also verify that your symbol search path (.sympath) is correct.
2: kd&gt; lm Dvm &lt;redacted&gt;
Browse full module list
start             end                 module name
fffff802`5ddc0000 fffff802`5def2000   &lt;redacted&gt;    (deferred)             
    Image path: \??\C:\Users\hack\Desktop\&lt;redacted&gt;.sys
    Image name: &lt;redacted&gt;.sys
    Browse all global symbols  functions  data
    Timestamp:        Thu Dec  3 22:05:51 2009 (4B18282F)
    CheckSum:         001370DF
    ImageSize:        00132000
    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4
    Information from resource tables:
</code></pre><figure class=center><img loading=lazy src=/images/Screenshot_20230213_040952.png></figure><p>at offset <code>0x110</code> is our security descriptor address</p><figure class=center><img loading=lazy src=/images/Screenshot_20230213_041632.png></figure><p>we can see the persmissions with the command <code>!sd</code></p><figure class=center><img loading=lazy src=/images/Screenshot_20230213_041716.png></figure><p>we can rebase the image in Ghidra by clicking the small memory icon in the main tool panel:</p><figure class=center><img loading=lazy src=/images/Screenshot_20230213_053700.png></figure><p><a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/debugger/-drvobj>!drvobj</a> with flag 0x02 can be used to get  entry points for the driver&rsquo;s dispatch routines:</p><pre tabindex=0><code class=language-windbg data-lang=windbg>2: kd&gt; !drvobj ffffb40222250e30 2
Driver object (ffffb40222250e30) is for:
 \Driver\&lt;redacted&gt;

DriverEntry:   fffff8025deee000	&lt;redacted&gt;
DriverStartIo: 00000000	
DriverUnload:  fffff8025dee9320	&lt;redacted&gt;
AddDevice:     fffff8025ddc2fb0	&lt;redacted&gt;

Dispatch routines:
[00] IRP_MJ_CREATE                      fffff8025deebee0	&lt;redacted&gt;+0x12bee0
[01] IRP_MJ_CREATE_NAMED_PIPE           fffff80237f29060	nt!IopInvalidDeviceRequest
[02] IRP_MJ_CLOSE                       fffff8025deec140	&lt;redacted&gt;+0x12c140
[03] IRP_MJ_READ                        fffff8025deebce0	&lt;redacted&gt;+0x12bce0
[04] IRP_MJ_WRITE                       fffff8025deea980	&lt;redacted&gt;+0x12a980
[...]
[0e] IRP_MJ_DEVICE_CONTROL              fffff8025deec750	&lt;redacted&gt;+0x12c750
</code></pre><p>and our entry to the IOCTL Dispatch should be somewhere at offset <code>0x12c750</code></p><figure class=center><img loading=lazy src=/images/Screenshot_20230213_054607.png></figure><p>A nice IOCTL dispatch routine can be seen below:</p><figure class=center><img loading=lazy src=/images/Screenshot_20230208_064843%201.png></figure><p>Sometimes you can save a lot of time looking for the <code>IOCompleteRequest</code> import from <code>NTOSKRNL.EXE</code> in the symbol tree, list x-references to those functions and walk backwards from there:</p><figure class=center><img loading=lazy src=/images/Screenshot_20230208_064222.png></figure><p>Now we are ready to inject a payload via filetest to see if our driver accepts IOCTL via user input.</p><figure class=center><img loading=lazy src=/images/Screenshot_20230209_122021.png></figure><figure class=center><img loading=lazy src=/images/Screenshot_20230213_055011.png></figure><p>As you can see below our EAX contains the IOCTL:</p><pre tabindex=0><code class=language-windbg data-lang=windbg>0: kd&gt; bp 0xfffff802`5dd34871
0: kd&gt; g
Breakpoint 0 hit
&lt;redacted&gt;+0x14871:
fffff802`5dd34871 3bc8            cmp     ecx,eax
0: kd&gt; r
rax=00000000001b2150 rbx=ffff9c8f66e4f6b0 rcx=00000000001b2150
rdx=ffff9c8f66bfbd70 rsi=0000000000000001 rdi=ffff9c8f66bfbe40
rip=fffff8025dd34871 rsp=ffffe98266a57610 rbp=0000000000000002
 r8=000000000000000e  r9=ffff9c8f66e4f6b0 r10=0000000000000000
r11=ffffc97f6f800000 r12=0000000000000000 r13=0000000000000000
r14=ffff9c8f66bfbd70 r15=0000000000000000
iopl=0         nv up ei pl nz na pe nc
cs=0010  ss=0018  ds=002b  es=002b  fs=0053  gs=002b             efl=00040202
&lt;redacted&gt;+0x14871:
fffff802`5dd34871 3bc8            cmp     ecx,eax
</code></pre><p>Now you should be able to start your research and inject your own payloads into the kernel driver handlers from user-land. In the next post we will finally break stuff and exploit a stack-based buffer overflow in one of the drivers.</p></div><footer class=post-footer></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://cschwarz1.github.io/>home</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a></span>
<span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script>
<script>(function(){const a=""=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>